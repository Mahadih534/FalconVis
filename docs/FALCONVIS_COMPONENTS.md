# FalconVis Components ðŸ”©

## Component Tree
FalconVis provides many prebuilt components which allow you to create powerful visualization and decisionmaking systems. There are currently three different systems for the FalconVis lib 

 - `data`
    - Manages constants in your codebase like the teams being used in the ui or the data you are reading
    - Provides methods for getting statistical data from your json generated by FalconScout
 - `automated`
    - Consists of math decisionmaking tools that can take anonymous functions and generate criteria that are used in components for data output
 - `components`
    - UI components or ui managers that use may use inline functions or more complicated automated classes in order to generate data

## Data
We have a lot of constants and prewritten methods for querying data via `CalculatedStats` and `Constants.js`. This should be the way you query data.

### Constants.js
In the `src/lib/data/Constants.js`, there are 4 different constants you can edit.

1. `Queries` is an enum of values you want to query from you data. For example, in FalconScout, if you are gathering upper hub data in teleop, you may have a data value of `Teleop Upper Hub: 10`. In order to reduce errors in FalconVis, we use enums so that you can autocomplete a dictionary value and not have spelling mistakes in your strings. There are two different formats for how you can setup a query
 - `One to One` is a way to set an enum for a single data value like ` TELEOP_UPPER_HUB: "Teleop Upper Hub"`
 - `One to MANY` is used in order to set a group for generating point values by giving the factors in a point value and their corresping values.
 ```javascript
 TELEOP_TOTAL: {
    "Teleop Lower Hub": 1, 
    "Teleop Upper Hub": 2
}
 ```
2. `Selections` is a way to set identifying data. We generally use these to set options for graphs and macros. We have a few pre-setup for IRI2022 and should be changed for your game. When we say `Selections.RED`, we are using it for getting the alliance type

3. `mandatoryMatchData` is the name of used entry values. If that is not correct, your data will not load. In 4099's data, in FalconScout, we use team_number as our id. **YOU MUST HAVE A VALUE FOR ALL OF THEM**

4. `JSONData` is the link to the hosted JSON data. If the data is local, you may be able to add the path in.

### CalculatedStats

The CalculatedStats class takes one parameter of `data` which is the json format that FalconScout exports its data in. It is advised that if you are using FalconVis, that your scoutingsystem is FalconScout.

There are 4 methods for querying data
 - `getAvrStat(team, stat)` works to get the average of a stat. You should pass in a Query value from the `Constants.Queries`

```javascript
stat.getAvrStat(4099, Queries.TELEOP_UPPER_HUB)

// return avrScore
```

 - `getTotalPoints(team, stat)` is a method to use the `One to MANY` Query type to take a portion of the game (Teleop, Auto, Endgame) and take the individual components and point values and get every game's score for that section.

```javascript
stats.getTotalPoints(4099, Queries.TELEOP_TOTAL)
// return [matchList[int], data[int]]
```

- `getScoreData(team, stat)` is a way to get a certain stat over time. For every game a team played, it will get the amount of times it did a certain stat.
```javascript
stats.getScoreData(4099, Queries.TELEOP_UPPER)
// return [matchList[int], data[int]]
```

 - `getMatchAllianceData(match, stat, alliance)` is a way of getting a certain stat from a certain game for every team on the alliance. 
 1. Pass a string of the match (e.g. `qm34`, `qf42`, `sf2`, `f1.3`)
 2. Pass in the Queries stat you are grabbing
 3. Pass the Selections alliance you are looking for. Make sure you spelling in Selections reflects what you have in your data

```javascript
stat.getMatchAllianceData("qm34", Queries.TELEOP_MISSES, SELECTIONS.RED)
// return [teams[int], data[int]]
```

## Automated Lib

### Factor
Factors are the building block of automated components. A factor is just a way of compartmentalizing a function used to generate a statisitical value.

```javascript

* @callback formula //Anonymous function to get statistical data based on team
* @param {number} bias //Multiplier on a factor internally to possible modify data to convert to score or other metric

new Factor(
    function (team) { 
        return stats.getAvrStat(
            team,
            Queries.TELEOP_UPPER_HUB
        )
    },
    5
)
```

In this example, we initialize a new `Factor` where we pass in an inline function. This inline function uses our CalculatedStats method in order to get data from our json file. Make sure that this can take a parameter since the method should take an `input` and give a statistical `output` back to the factor. 

You can add a **`bias`** to the Factor by multiplying the result of the function by a `bias`. This `bias` is the second parameter in the class

### Composite Stat
`Composite Stat` is how you create the criteria with the elements of it being the Factors. It takes two different parameters
```javascript 
* @param {Factor[]} factors // List of Factors in criteria
* @param {Number} threshold // setting boolean threshold of conditional if team passes criteria 

var comp_stat = new CompositeStat(
    [ //factors
        new Factor(
            function (team) { return stats.getAvrStat(team,Queries.TELEOP_UPPER_HUB)}
        ),
        new Factor(
            function (team) { return stats.getAvrStat(team,Queries.TELEOP_LOWER_HUB)}
        ),
    ],
    2 //threshold
)

comp_stat.getValue(4099) //returns [boolean result, float value]

```

When you run the `.getValue(team)` method, Composite stat passes the team passed in .getValue to every single factor, adds every value up and compares to threshold. If the value is `>= threshold` then the result is true, else it is false.

`.getValue(team)` returns an array of `[boolean result, float value]`

### WeightedStat
`WeightedStat` is similar to the idea of a `CompositeStat` except each of the Factors has a relative weightage in the criteria. This is done by converting the list of factors into a list of factor dictionaries with the following structure
```javascript
[
    {
        formula: Factor,
        weight: int
    },
    ...
    {
        formula: Factor,
        weight: int
    }
]
```
When implemented in code, it looks like
```javascript
* @param {Dict<string, Factor>[]} factors //List of Factors and their corresponding weights in the criteria
* @param {Number} threshold //Setting boolean threshold of conditional if team passes criteria

var weight_stat = new WeightedStat(
    [ //factors
        {
            formula: new Factor(
                function (team) { return stats.getAvrStat(team,Queries.TELEOP_UPPER_HUB)}
            ),
            weight: 10,
        },
        {
            formula: new Factor(
                function (team) { return stats.getAvrStat(team,Queries.TELEOP_LOWER_HUB)}
            ),
            weight: 20
        }
    ],
    4 //threshold
)

weight_stat.getValue(4099) //returns [boolean result, float value]
```

It will return the same values as a `CompositeStat`.

## Non-Graph Component Lib

### AutomatedMacro

AutomatedMacro is a way to display values of a system without having a graph. You pass in one of two criterion objects and using the criteria, you can display the returned value in a red or green color based on if it passes the threshold. The parameters are as follow (in order)

 - `id` - is the id of the parent element in the DOM that the graph will be added to (e.g. "blueAllianceContainer"). Type `String`
 - `title` - is the title that will be shown on the component on the ui. Type `String`
 - `stat` is where you pass the criteria object the macro will use for displaying calculated data
 - `selectedOptions` is a way to set the options that the automated macro will show. . Type `array<String>`

```javascript
var blueAlnc = new AutomatedMacro(
    "blueAllianceContainer",
    "Defense Options Auto",
    CompositeStat(
        [new Factor(
            function (team) { return stats.getAvrStat(team,Queries.TELEOP_UPPER_HUB)}
        )],
        2 //threshold
    ),
    blue
)
```

Generally, you will add these components to a `GraphManager` that is usually provided on the page. This will handle the change in the team value. The modal and corresponding HTML should already be created for you but if it isn't, here it is.

### Modal

Modal is the UI element that will be used to edit graphs. You pass them into graphs when they are initialized. It takes 4 parameters
 - `mainID` is the id of the DOM element of the modal
 - `openID` is the id of the button that will be used to mimic an opening movement of the modal. Can be a hidden button that you initialize.
 - `closeID` is the id of the button in the modal used to close it. Generally the save button is used
 - `formID` is the id of the DOM element where the checkboxes for selecting teams will go. Generally a div.

```javascript
var modal = new Modal(
    "editModal",    // mainID
    "fakeToggle",   // openID
    "getEditedData",    // closeID
    "editableFormContainer"     // formID
)
```

### GraphManager
`GraphManager` holds your graphs and can handle pushing new teams to each graph. Since the `AutomatedMacro` and `Graphs` all have the same method name for pushing new teams, you can simply add a graph to the `GraphManager` and it will handle pushing data. When you add a graph, you just pass a `Key` and a corresponding `Graph`

```javascript
var graphContainerBlue = new GraphManager()

graphContainerBlue.addGraph(
    "teleopPOTBlue",
    new LineGraph(
        "blueAllianceContainer",
        "Teleop POT - Blue",
        {},
        {
            formula: function(team) {return stats.getTotalPoints(team, Queries.TELEOP_TOTAL)},
            selectedOptions: blue,
            allOptions: Selections.TEAMS
        },
        modal,
        false
    )
)

graphContainerBlue.addGraph(
    "defenseAutomatedBlue",
    new AutomatedMacro(
        "blueAllianceContainer",
        "Defense Options Auto",
        defenseStat,
        blue
    )
)

graphContainerBlue.pushEditAll(blue) // Where push is handled for every graph
```

## Graphs

### **Important Default Info**

Graphs is what makes FalconVis so great. Graphs are very easy to configure (10 lines of code max :eyes:) and they are editable. **Editability** means that a person viewing the graph can reconfigure the graph directly on the UI to remove or add a team to their graph.

> **To edit a graph, you have to click on it**

Since it is based on [ApexCharts](https://apexcharts.com/docs/creating-first-javascript-chart/), there are parameters in the generation of graphs that will just be properties that ApexCharts needs (e.g. `plotOptions`).

There are 4 different graphs. `BarGraph`, `LineGraph`, `ScatterGraph`, `PieGraph` which represent what you would think they normally represent. Every single graph takes 6 different parameters (in order)
 - `parent_id` is the id of the parent DOM element of the graph
 - `title` is the title of the graph that will appear on the UI
 - `plotOptions` are just dictionaries of data that ApexCharts uses in order to configure the graph layout. If you do not need anything to be changed from default, make the value of the parameter `{}`. This is not a default parameter since in more complicated vis graphs, it will be used often.
 - `dataOptions` is how you give the 4099 Graph Wrapper Class the info for what data will be graphed. Each graph explanation below will explain its **custom** format for getting this data
 - `modal` is the class you pass to a graph for when it needs to edited. You generate a modal at the start, explained before.
 - `editable=true`, is a defualt parameter that sets the property that the graph can be edited. If it shouldn't be edited and have the x and y values constant, set editable to `false`


### Bar Graph
Make sure to read the section about argument structure before this section. `Bar Graph`'s `dataOptions` is done by three parameters in a dictionary.
 - `formula` is a dictionary of formulas or anonymous functions where a team number will be passed in and a value will be returned for that team. You can add multiple here if you want multiple bars per team
 ```javascript
 formula: {
    "Auto Upper": function(team) {return stats.getAvrStat(team, Queries.AUTO_UPPER_HUB)},
    "Teleop Upper": function(team) {return stats.getAvrStat(team, Queries.TELEOP_UPPER_HUB)}
}
 ```
 - `selectedOptions` is the initial teams that will be added to the graph. It **MUST** be a subset of `allOptions`
 - `allOptions` is the total lsit of teams that can be added and will be accessible on the `Modal`

```javascript
var driverRating = new BarGraph(
    "graphContainer",   // parent_id
    "Avr Driver Rating by Team",    // title
    {   // plotOptions
      bar: {
        horizontal: false
      }
    },
    {   //dataOptions
      formula: {
        "Auto Upper": function(team) {return stats.getAvrStat(team, Queries.AUTO_UPPER_HUB)},
        "Teleop Upper": function(team) {return stats.getAvrStat(team, Queries.TELEOP_UPPER_HUB)}
      },
      selectedOptions: [4099, 118, 180],
      allOptions: [33, 2056, 4499, 2468, 4099, 118, 180, 340, 5406]
    },
    modal   // modal,
    false   // editable
  )
```

### LineGraph
Make sure to read the section about argument structure before this section. `Line Graph`'s `dataOptions` is done by three parameters in a dictionary.
 - `formula` is an anonymous function that you will be passing to the LineGraph. It will have to return a list of the data that will be graphed in a line in the format of `[time[int], yData[int]]`
 - `selectedOptions` is the initial teams that will be added to the graph. It **MUST** be a subset of `allOptions`
 - `allOptions` is the total lsit of teams that can be added and will be accessible on the `Modal`

```javascript
var shooterOverTime = new LineGraph(
    "graphContainer",
    "Shooter over matches",
    {},
    {
      formula: function(team) {return stats.getScoreData(team, Queries.TELEOP_UPPER_HUB)},
      selectedOptions: [2056],
      allOptions: [33, 2056, 4499, 2468, 4099, 118, 180, 340]
    },
    modal,
)
```

### ScatterGraph
Make sure to read the section about argument structure before this section. `Scatter Graph`'s `dataOptions` is done by four parameters in a dictionary.
 - `formulaX` is an anonymous function that you will be passing to the LineGraph. It will have to return a list of the data that will be graphed in the xAxis. In the form of `[time[int], yData[int]]`
 - `formulaY` is an anonymous function that you will be passing to the LineGraph. It will have to return a list of the data that will be graphed in the yAxis. In the form of `[time[int], yData[int]]`
 - `selectedOptions` is the initial teams that will be added to the graph. It **MUST** be a subset of `allOptions`
 - `allOptions` is the total lsit of teams that can be added and will be accessible on the `Modal`

```javascript
var goodShooters = new ScatterGraph(
    "graphContainer",
    "Shooting by match by team",
    {},
    {
      formulaX: function(team) {return stats.getScoreData(team, Queries.TELEOP_UPPER_HUB)},
      formulaY: function(team) {return stats.getScoreData(team, Queries.AUTO_UPPER_HUB)},
      selectedOptions: [4099, 2056],
      allOptions: Selections.TEAMS
    },
    modal
)
```

### PieGraph
Make sure to read the section about argument structure before this section. `Pie Graph`'s `dataOptions` is done by three parameters in a dictionary.
 - `formula` is an anonymous function that you will be passing to the LineGraph. It will have to return a list of the data that will be graphed in a line in the format of `[label[any], series[int]]`
 - `selectedOptions` is the initial teams that will be added to the graph. It **MUST** be a subset of `allOptions`
 - `allOptions` is the total lsit of teams that can be added and will be accessible on the `Modal`

```javascript
var gameContribution = new PieGraph(
    "graphContainer",
    "shooting contrib by match",
    {},
    {
      formula: function(match) {return stats.getMatchAllianceData(match, Queries.TELEOP_UPPER_HUB, Selections.RED)},
      selectedOption: "qm1",
      allOptions: Selections.MATCHES
    },
    modal
)
```